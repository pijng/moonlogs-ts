/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Moonlogs
 * Moonlogs API
 *
 * OpenAPI spec version: 0.5.7
 * Contact: shalpack@gmail.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * 
     * @type {number}
     * @memberof ApiToken
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiToken
     */
    isRevoked: boolean;
}
/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    password: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    error: string;
    /**
     * 
     * @type {Array<Schema>}
     * @memberof InlineResponse200
     */
    data: Array<Schema>;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse200
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    error: string;
    /**
     * 
     * @type {Schema}
     * @memberof InlineResponse2001
     */
    data: Schema;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2001
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20010
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    error: string;
    /**
     * 
     * @type {ApiToken}
     * @memberof InlineResponse20010
     */
    data: ApiToken;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20010
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20011
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    error: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011
     */
    data: number;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20011
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20012
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    error: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof InlineResponse20012
     */
    data: Array<Tag>;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20012
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20013
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20013
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    error: string;
    /**
     * 
     * @type {Tag}
     * @memberof InlineResponse20013
     */
    data: Tag;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20013
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    error: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    data: number;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2002
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    error: string;
    /**
     * 
     * @type {Array<Record>}
     * @memberof InlineResponse2003
     */
    data: Array<Record>;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2003
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    error: string;
    /**
     * 
     * @type {Record}
     * @memberof InlineResponse2004
     */
    data: Record;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2004
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    error: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse2005
     */
    data: Array<User>;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2005
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    error: string;
    /**
     * 
     * @type {User}
     * @memberof InlineResponse2006
     */
    data: User;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2006
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2007
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    error: string;
    /**
     * Deleted User's ID
     * @type {number}
     * @memberof InlineResponse2007
     */
    data: number;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2007
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    error: string;
    /**
     * 
     * @type {Session}
     * @memberof InlineResponse2008
     */
    data: Session;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2008
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2009
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    error: string;
    /**
     * 
     * @type {Array<ApiToken>}
     * @memberof InlineResponse2009
     */
    data: Array<ApiToken>;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2009
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Level {
    Trace = <any> 'Trace',
    Debug = <any> 'Debug',
    Info = <any> 'Info',
    Warn = <any> 'Warn',
    Error = <any> 'Error',
    Fatal = <any> 'Fatal'
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    count: number;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    pages: number;
}
/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * 
     * @type {number}
     * @memberof Record
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    schemaName: string;
    /**
     * 
     * @type {number}
     * @memberof Record
     */
    schemaId?: number;
    /**
     * 
     * @type {any}
     * @memberof Record
     */
    query: any;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    kind: string;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    groupHash?: string;
    /**
     * 
     * @type {Level}
     * @memberof Record
     */
    level?: Level;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    Member = <any> 'Member',
    Admin = <any> 'Admin'
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    name: string;
    /**
     * 
     * @type {Array<SchemaField>}
     * @memberof Schema
     */
    fields: Array<SchemaField>;
    /**
     * 
     * @type {Array<SchemaKind>}
     * @memberof Schema
     */
    kinds: Array<SchemaKind>;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    tagId?: number;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    retentionDays?: number;
}
/**
 * 
 * @export
 * @interface SchemaField
 */
export interface SchemaField {
    /**
     * 
     * @type {string}
     * @memberof SchemaField
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SchemaField
     */
    name: string;
}
/**
 * 
 * @export
 * @interface SchemaKind
 */
export interface SchemaKind {
    /**
     * 
     * @type {string}
     * @memberof SchemaKind
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SchemaKind
     */
    name: string;
}
/**
 * 
 * @export
 * @interface SchemaSearch
 */
export interface SchemaSearch {
    /**
     * 
     * @type {string}
     * @memberof SchemaSearch
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SchemaSearch
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    token: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    passwordDigest?: string;
    /**
     * 
     * @type {Role}
     * @memberof User
     */
    role: Role;
    /**
     * 
     * @type {Array<number>}
     * @memberof User
     */
    tags: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isRevoked: boolean;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/api_tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiApiTokensIdDelete.');
            }
            const localVarPath = `/api/api_tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiApiTokensIdGet.');
            }
            const localVarPath = `/api/api_tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ApiToken} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdPut(id: number, body?: ApiToken, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiApiTokensIdPut.');
            }
            const localVarPath = `/api/api_tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiToken} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensPost(body?: ApiToken, options: any = {}): FetchArgs {
            const localVarPath = `/api/api_tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGet(page?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/logs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schemaName 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGroupSchemaNameHashGet(schemaName: string, hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'schemaName' is not null or undefined
            if (schemaName === null || schemaName === undefined) {
                throw new RequiredError('schemaName','Required parameter schemaName was null or undefined when calling apiLogsGroupSchemaNameHashGet.');
            }
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling apiLogsGroupSchemaNameHashGet.');
            }
            const localVarPath = `/api/logs/group/{schema_name}/{hash}`
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiLogsIdGet.');
            }
            const localVarPath = `/api/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Record} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsPost(body?: Record, options: any = {}): FetchArgs {
            const localVarPath = `/api/logs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Record" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Record} [body] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [from] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
         * @param {string} [to] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsSearchPost(body?: Record, page?: number, limit?: number, from?: string, to?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/logs/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Record" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/schemas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiSchemasIdDelete.');
            }
            const localVarPath = `/api/schemas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiSchemasIdGet.');
            }
            const localVarPath = `/api/schemas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Schema} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdPut(id: number, body?: Schema, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiSchemasIdPut.');
            }
            const localVarPath = `/api/schemas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Schema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Schema} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasPost(body?: Schema, options: any = {}): FetchArgs {
            const localVarPath = `/api/schemas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Schema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSessionGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/session`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSessionPost(body?: Credentials, options: any = {}): FetchArgs {
            const localVarPath = `/api/session`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Credentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSetupRegisterAdminPost(body?: User, options: any = {}): FetchArgs {
            const localVarPath = `/api/setup/register_admin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTagsIdDelete.');
            }
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTagsIdGet.');
            }
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Tag} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdPut(id: number, body?: Tag, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTagsIdPut.');
            }
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tag} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost(body?: Tag, options: any = {}): FetchArgs {
            const localVarPath = `/api/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdDelete.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdGet.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut(id: number, body?: User, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdPut.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(body?: User, options: any = {}): FetchArgs {
            const localVarPath = `/api/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http1 required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiApiTokensGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiApiTokensIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiApiTokensIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ApiToken} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdPut(id: number, body?: ApiToken, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiApiTokensIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ApiToken} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensPost(body?: ApiToken, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiApiTokensPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGet(page?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiLogsGet(page, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} schemaName 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGroupSchemaNameHashGet(schemaName: string, hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiLogsGroupSchemaNameHashGet(schemaName, hash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiLogsIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Record} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsPost(body?: Record, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiLogsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Record} [body] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [from] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
         * @param {string} [to] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsSearchPost(body?: Record, page?: number, limit?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiLogsSearchPost(body, page, limit, from, to, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSchemasGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSchemasIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSchemasIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Schema} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdPut(id: number, body?: Schema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSchemasIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Schema} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasPost(body?: Schema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSchemasPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSessionGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSessionGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSessionPost(body?: Credentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSessionPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSetupRegisterAdminPost(body?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiSetupRegisterAdminPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiTagsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiTagsIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiTagsIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Tag} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdPut(id: number, body?: Tag, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiTagsIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Tag} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost(body?: Tag, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiTagsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiUsersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiUsersIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiUsersIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut(id: number, body?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiUsersIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(body?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiUsersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensGet(options?: any) {
            return DefaultApiFp(configuration).apiApiTokensGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdDelete(id: number, options?: any) {
            return DefaultApiFp(configuration).apiApiTokensIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdGet(id: number, options?: any) {
            return DefaultApiFp(configuration).apiApiTokensIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {ApiToken} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensIdPut(id: number, body?: ApiToken, options?: any) {
            return DefaultApiFp(configuration).apiApiTokensIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ApiToken} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiTokensPost(body?: ApiToken, options?: any) {
            return DefaultApiFp(configuration).apiApiTokensPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGet(page?: number, limit?: number, options?: any) {
            return DefaultApiFp(configuration).apiLogsGet(page, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} schemaName 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGroupSchemaNameHashGet(schemaName: string, hash: string, options?: any) {
            return DefaultApiFp(configuration).apiLogsGroupSchemaNameHashGet(schemaName, hash, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsIdGet(id: number, options?: any) {
            return DefaultApiFp(configuration).apiLogsIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Record} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsPost(body?: Record, options?: any) {
            return DefaultApiFp(configuration).apiLogsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Record} [body] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [from] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
         * @param {string} [to] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsSearchPost(body?: Record, page?: number, limit?: number, from?: string, to?: string, options?: any) {
            return DefaultApiFp(configuration).apiLogsSearchPost(body, page, limit, from, to, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasGet(options?: any) {
            return DefaultApiFp(configuration).apiSchemasGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdDelete(id: number, options?: any) {
            return DefaultApiFp(configuration).apiSchemasIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdGet(id: number, options?: any) {
            return DefaultApiFp(configuration).apiSchemasIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {Schema} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasIdPut(id: number, body?: Schema, options?: any) {
            return DefaultApiFp(configuration).apiSchemasIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Schema} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemasPost(body?: Schema, options?: any) {
            return DefaultApiFp(configuration).apiSchemasPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSessionGet(options?: any) {
            return DefaultApiFp(configuration).apiSessionGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSessionPost(body?: Credentials, options?: any) {
            return DefaultApiFp(configuration).apiSessionPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSetupRegisterAdminPost(body?: User, options?: any) {
            return DefaultApiFp(configuration).apiSetupRegisterAdminPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet(options?: any) {
            return DefaultApiFp(configuration).apiTagsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdDelete(id: number, options?: any) {
            return DefaultApiFp(configuration).apiTagsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdGet(id: number, options?: any) {
            return DefaultApiFp(configuration).apiTagsIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {Tag} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdPut(id: number, body?: Tag, options?: any) {
            return DefaultApiFp(configuration).apiTagsIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Tag} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost(body?: Tag, options?: any) {
            return DefaultApiFp(configuration).apiTagsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(options?: any) {
            return DefaultApiFp(configuration).apiUsersGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: number, options?: any) {
            return DefaultApiFp(configuration).apiUsersIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: number, options?: any) {
            return DefaultApiFp(configuration).apiUsersIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut(id: number, body?: User, options?: any) {
            return DefaultApiFp(configuration).apiUsersIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {User} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(body?: User, options?: any) {
            return DefaultApiFp(configuration).apiUsersPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiApiTokensGet(options?: any) {
        return DefaultApiFp(this.configuration).apiApiTokensGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiApiTokensIdDelete(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiApiTokensIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiApiTokensIdGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiApiTokensIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {ApiToken} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiApiTokensIdPut(id: number, body?: ApiToken, options?: any) {
        return DefaultApiFp(this.configuration).apiApiTokensIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ApiToken} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiApiTokensPost(body?: ApiToken, options?: any) {
        return DefaultApiFp(this.configuration).apiApiTokensPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiLogsGet(page?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiLogsGet(page, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} schemaName 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiLogsGroupSchemaNameHashGet(schemaName: string, hash: string, options?: any) {
        return DefaultApiFp(this.configuration).apiLogsGroupSchemaNameHashGet(schemaName, hash, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiLogsIdGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiLogsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Record} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiLogsPost(body?: Record, options?: any) {
        return DefaultApiFp(this.configuration).apiLogsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Record} [body] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [from] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
     * @param {string} [to] Time in format \&quot;YYYY-DD-MMTHH:SS\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiLogsSearchPost(body?: Record, page?: number, limit?: number, from?: string, to?: string, options?: any) {
        return DefaultApiFp(this.configuration).apiLogsSearchPost(body, page, limit, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSchemasGet(options?: any) {
        return DefaultApiFp(this.configuration).apiSchemasGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSchemasIdDelete(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiSchemasIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSchemasIdGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiSchemasIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {Schema} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSchemasIdPut(id: number, body?: Schema, options?: any) {
        return DefaultApiFp(this.configuration).apiSchemasIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Schema} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSchemasPost(body?: Schema, options?: any) {
        return DefaultApiFp(this.configuration).apiSchemasPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSessionGet(options?: any) {
        return DefaultApiFp(this.configuration).apiSessionGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Credentials} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSessionPost(body?: Credentials, options?: any) {
        return DefaultApiFp(this.configuration).apiSessionPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {User} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSetupRegisterAdminPost(body?: User, options?: any) {
        return DefaultApiFp(this.configuration).apiSetupRegisterAdminPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiTagsGet(options?: any) {
        return DefaultApiFp(this.configuration).apiTagsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiTagsIdDelete(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiTagsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiTagsIdGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiTagsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {Tag} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiTagsIdPut(id: number, body?: Tag, options?: any) {
        return DefaultApiFp(this.configuration).apiTagsIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Tag} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiTagsPost(body?: Tag, options?: any) {
        return DefaultApiFp(this.configuration).apiTagsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersGet(options?: any) {
        return DefaultApiFp(this.configuration).apiUsersGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersIdDelete(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiUsersIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersIdGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).apiUsersIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {User} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersIdPut(id: number, body?: User, options?: any) {
        return DefaultApiFp(this.configuration).apiUsersIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {User} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersPost(body?: User, options?: any) {
        return DefaultApiFp(this.configuration).apiUsersPost(body, options)(this.fetch, this.basePath);
    }

}
