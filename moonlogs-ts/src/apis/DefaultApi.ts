/* tslint:disable */
/* eslint-disable */
/**
 * Moonlogs
 * Moonlogs API
 *
 * The version of the OpenAPI document: 0.5.10
 * Contact: shalpack@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ApiToken,
    ApiTokenFromJSON,
    ApiTokenToJSON,
    Credentials,
    CredentialsFromJSON,
    CredentialsToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse20010,
    InlineResponse20010FromJSON,
    InlineResponse20010ToJSON,
    InlineResponse20011,
    InlineResponse20011FromJSON,
    InlineResponse20011ToJSON,
    InlineResponse20012,
    InlineResponse20012FromJSON,
    InlineResponse20012ToJSON,
    InlineResponse20013,
    InlineResponse20013FromJSON,
    InlineResponse20013ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    InlineResponse2004,
    InlineResponse2004FromJSON,
    InlineResponse2004ToJSON,
    InlineResponse2005,
    InlineResponse2005FromJSON,
    InlineResponse2005ToJSON,
    InlineResponse2006,
    InlineResponse2006FromJSON,
    InlineResponse2006ToJSON,
    InlineResponse2007,
    InlineResponse2007FromJSON,
    InlineResponse2007ToJSON,
    InlineResponse2008,
    InlineResponse2008FromJSON,
    InlineResponse2008ToJSON,
    InlineResponse2009,
    InlineResponse2009FromJSON,
    InlineResponse2009ToJSON,
    Record,
    RecordFromJSON,
    RecordToJSON,
    Schema,
    SchemaFromJSON,
    SchemaToJSON,
    Tag,
    TagFromJSON,
    TagToJSON,
    User,
    UserFromJSON,
    UserToJSON,
} from '../models';

export interface ApiApiTokensIdDeleteRequest {
    id: number;
}

export interface ApiApiTokensIdGetRequest {
    id: number;
}

export interface ApiApiTokensIdPutRequest {
    id: number;
    apiToken?: ApiToken;
}

export interface ApiApiTokensPostRequest {
    apiToken?: ApiToken;
}

export interface ApiLogsGetRequest {
    page?: number;
    limit?: number;
}

export interface ApiLogsGroupSchemaNameHashGetRequest {
    schemaName: string;
    hash: string;
}

export interface ApiLogsIdGetRequest {
    id: number;
}

export interface ApiLogsPostRequest {
    record?: Record;
}

export interface ApiLogsSearchPostRequest {
    page?: number;
    limit?: number;
    from?: string;
    to?: string;
    record?: Record;
}

export interface ApiSchemasIdDeleteRequest {
    id: number;
}

export interface ApiSchemasIdGetRequest {
    id: number;
}

export interface ApiSchemasIdPutRequest {
    id: number;
    schema?: Schema;
}

export interface ApiSchemasPostRequest {
    schema?: Schema;
}

export interface ApiSessionPostRequest {
    credentials?: Credentials;
}

export interface ApiSetupRegisterAdminPostRequest {
    user?: User;
}

export interface ApiTagsIdDeleteRequest {
    id: number;
}

export interface ApiTagsIdGetRequest {
    id: number;
}

export interface ApiTagsIdPutRequest {
    id: number;
    tag?: Tag;
}

export interface ApiTagsPostRequest {
    tag?: Tag;
}

export interface ApiUsersIdDeleteRequest {
    id: number;
}

export interface ApiUsersIdGetRequest {
    id: number;
}

export interface ApiUsersIdPutRequest {
    id: number;
    user?: User;
}

export interface ApiUsersPostRequest {
    user?: User;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     */
    async apiApiTokensGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2009>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/api_tokens`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2009FromJSON(jsonValue));
    }

    /**
     */
    async apiApiTokensGet(initOverrides?: RequestInit): Promise<InlineResponse2009> {
        const response = await this.apiApiTokensGetRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async apiApiTokensIdDeleteRaw(requestParameters: ApiApiTokensIdDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20011>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiApiTokensIdDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/api_tokens/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20011FromJSON(jsonValue));
    }

    /**
     */
    async apiApiTokensIdDelete(requestParameters: ApiApiTokensIdDeleteRequest, initOverrides?: RequestInit): Promise<InlineResponse20011> {
        const response = await this.apiApiTokensIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiApiTokensIdGetRaw(requestParameters: ApiApiTokensIdGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20010>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiApiTokensIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/api_tokens/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20010FromJSON(jsonValue));
    }

    /**
     */
    async apiApiTokensIdGet(requestParameters: ApiApiTokensIdGetRequest, initOverrides?: RequestInit): Promise<InlineResponse20010> {
        const response = await this.apiApiTokensIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiApiTokensIdPutRaw(requestParameters: ApiApiTokensIdPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20010>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiApiTokensIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/api_tokens/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ApiTokenToJSON(requestParameters.apiToken),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20010FromJSON(jsonValue));
    }

    /**
     */
    async apiApiTokensIdPut(requestParameters: ApiApiTokensIdPutRequest, initOverrides?: RequestInit): Promise<InlineResponse20010> {
        const response = await this.apiApiTokensIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiApiTokensPostRaw(requestParameters: ApiApiTokensPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20010>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/api_tokens`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiTokenToJSON(requestParameters.apiToken),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20010FromJSON(jsonValue));
    }

    /**
     */
    async apiApiTokensPost(requestParameters: ApiApiTokensPostRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse20010> {
        const response = await this.apiApiTokensPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLogsGetRaw(requestParameters: ApiLogsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2003>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/logs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     */
    async apiLogsGet(requestParameters: ApiLogsGetRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse2003> {
        const response = await this.apiLogsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLogsGroupSchemaNameHashGetRaw(requestParameters: ApiLogsGroupSchemaNameHashGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2003>> {
        if (requestParameters.schemaName === null || requestParameters.schemaName === undefined) {
            throw new runtime.RequiredError('schemaName','Required parameter requestParameters.schemaName was null or undefined when calling apiLogsGroupSchemaNameHashGet.');
        }

        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling apiLogsGroupSchemaNameHashGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/logs/group/{schema_name}/{hash}`.replace(`{${"schema_name"}}`, encodeURIComponent(String(requestParameters.schemaName))).replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     */
    async apiLogsGroupSchemaNameHashGet(requestParameters: ApiLogsGroupSchemaNameHashGetRequest, initOverrides?: RequestInit): Promise<InlineResponse2003> {
        const response = await this.apiLogsGroupSchemaNameHashGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLogsIdGetRaw(requestParameters: ApiLogsIdGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2004>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiLogsIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/logs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2004FromJSON(jsonValue));
    }

    /**
     */
    async apiLogsIdGet(requestParameters: ApiLogsIdGetRequest, initOverrides?: RequestInit): Promise<InlineResponse2004> {
        const response = await this.apiLogsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLogsPostRaw(requestParameters: ApiLogsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2004>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/logs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecordToJSON(requestParameters.record),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2004FromJSON(jsonValue));
    }

    /**
     */
    async apiLogsPost(requestParameters: ApiLogsPostRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse2004> {
        const response = await this.apiLogsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLogsSearchPostRaw(requestParameters: ApiLogsSearchPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2003>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/logs/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecordToJSON(requestParameters.record),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     */
    async apiLogsSearchPost(requestParameters: ApiLogsSearchPostRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse2003> {
        const response = await this.apiLogsSearchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSchemasGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/schemas`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     */
    async apiSchemasGet(initOverrides?: RequestInit): Promise<InlineResponse200> {
        const response = await this.apiSchemasGetRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSchemasIdDeleteRaw(requestParameters: ApiSchemasIdDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2002>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSchemasIdDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/schemas/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     */
    async apiSchemasIdDelete(requestParameters: ApiSchemasIdDeleteRequest, initOverrides?: RequestInit): Promise<InlineResponse2002> {
        const response = await this.apiSchemasIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSchemasIdGetRaw(requestParameters: ApiSchemasIdGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2001>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSchemasIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/schemas/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     */
    async apiSchemasIdGet(requestParameters: ApiSchemasIdGetRequest, initOverrides?: RequestInit): Promise<InlineResponse2001> {
        const response = await this.apiSchemasIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSchemasIdPutRaw(requestParameters: ApiSchemasIdPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2001>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSchemasIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/schemas/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SchemaToJSON(requestParameters.schema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     */
    async apiSchemasIdPut(requestParameters: ApiSchemasIdPutRequest, initOverrides?: RequestInit): Promise<InlineResponse2001> {
        const response = await this.apiSchemasIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSchemasPostRaw(requestParameters: ApiSchemasPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2001>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/schemas`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemaToJSON(requestParameters.schema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     */
    async apiSchemasPost(requestParameters: ApiSchemasPostRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse2001> {
        const response = await this.apiSchemasPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSessionGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2008>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/session`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2008FromJSON(jsonValue));
    }

    /**
     */
    async apiSessionGet(initOverrides?: RequestInit): Promise<InlineResponse2008> {
        const response = await this.apiSessionGetRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSessionPostRaw(requestParameters: ApiSessionPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2008>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/session`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CredentialsToJSON(requestParameters.credentials),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2008FromJSON(jsonValue));
    }

    /**
     */
    async apiSessionPost(requestParameters: ApiSessionPostRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse2008> {
        const response = await this.apiSessionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSetupRegisterAdminPostRaw(requestParameters: ApiSetupRegisterAdminPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<User>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/setup/register_admin`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserToJSON(requestParameters.user),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     */
    async apiSetupRegisterAdminPost(requestParameters: ApiSetupRegisterAdminPostRequest = {}, initOverrides?: RequestInit): Promise<User> {
        const response = await this.apiSetupRegisterAdminPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiTagsGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20012>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/tags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20012FromJSON(jsonValue));
    }

    /**
     */
    async apiTagsGet(initOverrides?: RequestInit): Promise<InlineResponse20012> {
        const response = await this.apiTagsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async apiTagsIdDeleteRaw(requestParameters: ApiTagsIdDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20011>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiTagsIdDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/tags/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20011FromJSON(jsonValue));
    }

    /**
     */
    async apiTagsIdDelete(requestParameters: ApiTagsIdDeleteRequest, initOverrides?: RequestInit): Promise<InlineResponse20011> {
        const response = await this.apiTagsIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiTagsIdGetRaw(requestParameters: ApiTagsIdGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20013>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiTagsIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/tags/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20013FromJSON(jsonValue));
    }

    /**
     */
    async apiTagsIdGet(requestParameters: ApiTagsIdGetRequest, initOverrides?: RequestInit): Promise<InlineResponse20013> {
        const response = await this.apiTagsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiTagsIdPutRaw(requestParameters: ApiTagsIdPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20013>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiTagsIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/tags/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TagToJSON(requestParameters.tag),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20013FromJSON(jsonValue));
    }

    /**
     */
    async apiTagsIdPut(requestParameters: ApiTagsIdPutRequest, initOverrides?: RequestInit): Promise<InlineResponse20013> {
        const response = await this.apiTagsIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiTagsPostRaw(requestParameters: ApiTagsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse20013>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/tags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TagToJSON(requestParameters.tag),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20013FromJSON(jsonValue));
    }

    /**
     */
    async apiTagsPost(requestParameters: ApiTagsPostRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse20013> {
        const response = await this.apiTagsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiUsersGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2005>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2005FromJSON(jsonValue));
    }

    /**
     */
    async apiUsersGet(initOverrides?: RequestInit): Promise<InlineResponse2005> {
        const response = await this.apiUsersGetRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async apiUsersIdDeleteRaw(requestParameters: ApiUsersIdDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2007>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUsersIdDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2007FromJSON(jsonValue));
    }

    /**
     */
    async apiUsersIdDelete(requestParameters: ApiUsersIdDeleteRequest, initOverrides?: RequestInit): Promise<InlineResponse2007> {
        const response = await this.apiUsersIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiUsersIdGetRaw(requestParameters: ApiUsersIdGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2006>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUsersIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2006FromJSON(jsonValue));
    }

    /**
     */
    async apiUsersIdGet(requestParameters: ApiUsersIdGetRequest, initOverrides?: RequestInit): Promise<InlineResponse2006> {
        const response = await this.apiUsersIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiUsersIdPutRaw(requestParameters: ApiUsersIdPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2006>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUsersIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserToJSON(requestParameters.user),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2006FromJSON(jsonValue));
    }

    /**
     */
    async apiUsersIdPut(requestParameters: ApiUsersIdPutRequest, initOverrides?: RequestInit): Promise<InlineResponse2006> {
        const response = await this.apiUsersIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiUsersPostRaw(requestParameters: ApiUsersPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2006>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http1", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserToJSON(requestParameters.user),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2006FromJSON(jsonValue));
    }

    /**
     */
    async apiUsersPost(requestParameters: ApiUsersPostRequest = {}, initOverrides?: RequestInit): Promise<InlineResponse2006> {
        const response = await this.apiUsersPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
